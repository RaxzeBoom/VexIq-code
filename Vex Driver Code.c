#pragma config(Motor,  motor2,          SPIN2,         tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor3,          SPIN1,         tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SMLIB_TPR_393Turbo     261.333
#define SMLIB_TPR_393Speed     392.0
#define SMLIB_TPR_393Torque    627.2
#define SMLIB_TPR_393Quad      360.0
float calculateVelocityBetter( tMotor port, float gear_ratio = 1.0 )
	{
    static  long  nSysTime_last;
    static  long  encoder_counts_last;
    static  float ticks_per_rev = SMLIB_TPR_393Speed; // fixed, known motor

    int     delta_ms;
    int     delta_enc;
    long    encoder_counts;
    float   motor_velocity;

    // Get current encoder value
    encoder_counts = nMotorEncoder[ port ];

    // This is just used so we don't need to know how often we are called
    // how many mS since we were last here
    delta_ms = nSysTime - nSysTime_last;
    nSysTime_last = nSysTime;

    // Change in encoder count
    delta_enc = (encoder_counts - encoder_counts_last);

    // save last position
    encoder_counts_last = encoder_counts;

    // Calculate velocity in rpm
    motor_velocity = (1000.0 / delta_ms) * delta_enc * 60.0 / ticks_per_rev;

    // multiply by any gear ratio's being used
    return( motor_velocity * gear_ratio );
	}

task main()
{
	repeat(forever)
  {

setMotorBrakeMode(2,motorCoast);
setMotorBrakeMode(1,motorCoast);
	armControl(2, BtnRUp, BtnRDown, 100);
	armControl(1 ,BtnRUp, BtnRDown, 100);
displayVariableValues(2,calculateVelocityBetter(2));



  }



}
